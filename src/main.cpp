#include <iostream>
#include <vector>
#include <cmath>

#include "Display3DMesh.h"
#include "PhotometricStereo.h"
#include <opencv2/video/background_segm.hpp>
#include <opencv2/video/video.hpp>

using namespace cv;
using namespace std;



// Finding Contours

Mat src; Mat src_gray;
int thresh = 100;
int max_thresh = 255;
RNG rng(12345);

/** @function thresh_callback */
void thresh_callback(int, void*)
{
	Mat canny_output;
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;

	/// Detect edges using canny
	Canny(src_gray, canny_output, thresh, thresh * 2, 3);
	/// Find contours
	findContours(canny_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

	/// Draw contours
	Mat drawing = Mat::zeros(canny_output.size(), CV_8UC3);
	for (int i = 0; i< contours.size(); i++)
	{
		Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, Point());
	}

	/// Show in a window
	namedWindow("Contours", CV_WINDOW_AUTOSIZE);
	imshow("Contours", canny_output);

	contours.clear(); // Error!!
}






// Image processing checking
//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;

void processImages(char* fistFrameFilename) {
	//read the first file of the sequence
	frame = imread(fistFrameFilename);
	namedWindow("Display windowsss", WINDOW_AUTOSIZE);// Create a window for display.
	imshow("Display windowss", frame);
	if (!frame.data){
		//error in opening the first image
		cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
		exit(EXIT_FAILURE);
	}
	//current image filename
	string fn(fistFrameFilename);
	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27){
		//update the background model
		//ALSO HERE!!!!
		pMOG->operator()(frame, fgMaskMOG);
		pMOG2->operator()(frame, fgMaskMOG2);
		//get the frame number and write it on the current frame
		size_t index = fn.find_last_of("/");
		if (index == string::npos) {
			index = fn.find_last_of("\\");
		}
		size_t index2 = fn.find_last_of(".");
		string prefix = fn.substr(0, index + 1);
		string suffix = fn.substr(index2);
		string frameNumberString = fn.substr(index + 1, index2 - index - 1);
		istringstream iss(frameNumberString);
		int frameNumber = 0;
		iss >> frameNumber;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);
		imshow("FG Mask MOG", fgMaskMOG);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		//get the input from the keyboard
		keyboard = waitKey(30);
		//search for the next image in the sequence
		ostringstream oss;
		oss << (frameNumber + 1);
		string nextFrameNumberString = oss.str();
		string two = "2";
		string nextFrameFilename = prefix + two + suffix;
		//read the next frame

		frame = imread(nextFrameFilename);
		if (!frame.data){
			//error in opening the next image in the sequence
			cerr << "Unable to open image frame: " << nextFrameFilename << endl;
			exit(EXIT_FAILURE);
		}
		//update the path of the current frame
		fn.assign(nextFrameFilename);
	}
	//imshow("FG Mask MOG", fgMaskMOG);
	imwrite("../images/3.jpg", fgMaskMOG);
}


int main(int argc, char *argv[]) {
	
	const int NUM_IMGS = 4;
	const string CALIBRATION = "../images/RGBLights/light."; //"../images/lights/chrome.";
	const string MODEL = "../images/EggRGBFullOn/egg.";
    

	PhotometricStereo photometric = PhotometricStereo(NUM_IMGS , CALIBRATION , MODEL);

	//display normals in colour coded form
	cv::Mat Normalmap;
	const int height = photometric.normal.rows;
	const int width = photometric.normal.cols;
	cv::cvtColor(photometric.normal, Normalmap, CV_BGR2RGB);
	for (int x = 0; x < width; x++) {
		for (int y = 0; y < height; y++) {
			Vec3f tmp = Normalmap.at<Vec3f>(Point(x, y));
			float xaa = tmp[1];
			float yaa = tmp[2];
			Normalmap.at<Vec3f>(Point(x, y))[1] = -yaa;
			Normalmap.at<Vec3f>(Point(x, y))[2] = xaa;
		}
	}
	cv::imshow("Normalmap", (Normalmap +1.)/2.);
	imwrite("../images/Normal.jpg", (Normalmap + 1.)*255 / 2.);
	
	cv::Mat Z = photometric.globalHeights(photometric.pGradient, photometric.qGradient);

	// display reconstruction 
	Display3DMesh mesh3D = Display3DMesh(photometric.pGradient.cols,photometric.pGradient.rows, Z);
	mesh3D.display(); 

	cv::waitKey();
	return 0;





	/*
	
	// IMAGE processing
	//print help information
	//help();

	//check for the input parameter correctness
	//if (argc != 3) {
		//cerr << "Incorret input list" << endl;
		//cerr << "exiting..." << endl;
		//return EXIT_FAILURE;
	//}

	//create GUI windows
	namedWindow("Frame");
	namedWindow("FG Mask MOG");
	namedWindow("FG Mask MOG 2");

	char* imgfolder = "../images/1.JPG";

	//create Background Subtractor objects
	//NOTE HERE!!!!
	pMOG = new BackgroundSubtractorMOG(); //MOG approach
	pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach

	//if (strcmp(argv[1], "-vid") == 0) {
		//input data coming from a video
		//processVideo(argv[2]);
	//}
	//else 
	if (true){//strcmp(argv[1], "-img") == 0) {
		//input data coming from a sequence of images
		processImages(imgfolder);
	}
	else {
		//error in reading input parameters
		cerr << "Please, check the input parameters." << endl;
		cerr << "Exiting..." << endl;
		return EXIT_FAILURE;
	}

	//destroy GUI windows
    cv:waitKey();
	int hehe;
	cin >> hehe;
	destroyAllWindows();
	return EXIT_SUCCESS;

	*/

	/*
	// FINDING CONTOURS
	/// Load source image and convert it to gray
	src = imread("../images/1.JPG", 1);
	Mat ret;
	Mat thresh2;
	threshold(src, ret, 254, 255, THRESH_BINARY_INV);

	/// Convert image to gray and blur it
	cvtColor(src, src_gray, CV_BGR2GRAY);
	blur(src_gray, src_gray, Size(3, 3));

	/// Create Window
	char* source_window = "Source";
	namedWindow(source_window, CV_WINDOW_AUTOSIZE);
	imshow(source_window, ret);

	createTrackbar(" Canny thresh:", "Source", &thresh, max_thresh, thresh_callback);
	thresh_callback(0, 0);

	waitKey(0);
	return(0);*/
}